-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Lambda.Par
  ( happyError
  , myLexer
  , pTerm
  , pType
  ) where

import Prelude

import qualified Lambda.Abs
import Lambda.Lex

}

%name pTerm Term
%name pType Type
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('     { PT _ (TS _ 1)   }
  ')'     { PT _ (TS _ 2)   }
  '*'     { PT _ (TS _ 3)   }
  '+'     { PT _ (TS _ 4)   }
  '->'    { PT _ (TS _ 5)   }
  '.'     { PT _ (TS _ 6)   }
  ':'     { PT _ (TS _ 7)   }
  'A'     { PT _ (TS _ 8)   }
  'B'     { PT _ (TS _ 9)   }
  'Bot'   { PT _ (TS _ 10)  }
  'C'     { PT _ (TS _ 11)  }
  'E'     { PT _ (TS _ 12)  }
  'T'     { PT _ (TS _ 13)  }
  '\\'    { PT _ (TS _ 14)  }
  'abort' { PT _ (TS _ 15)  }
  'as'    { PT _ (TS _ 16)  }
  'case'  { PT _ (TS _ 17)  }
  'fst'   { PT _ (TS _ 18)  }
  'inl'   { PT _ (TS _ 19)  }
  'inr'   { PT _ (TS _ 20)  }
  'of'    { PT _ (TS _ 21)  }
  'snd'   { PT _ (TS _ 22)  }
  '|'     { PT _ (TS _ 23)  }
  L_Var   { PT _ (T_Var $$) }

%%

Var :: { Lambda.Abs.Var }
Var  : L_Var { Lambda.Abs.Var $1 }

Term :: { Lambda.Abs.Term }
Term
  : Var { Lambda.Abs.Variable $1 }
  | '(' Term Term ')' { Lambda.Abs.Application $2 $3 }
  | '(' '\\' Var ':' Type '.' Term ')' { Lambda.Abs.Abstraction $3 $5 $7 }
  | 'fst' Term { Lambda.Abs.Fst $2 }
  | 'snd' Term { Lambda.Abs.Snd $2 }
  | 'inl' Term 'as' Type { Lambda.Abs.Inl $2 $4 }
  | 'inr' Term 'as' Type { Lambda.Abs.Inr $2 $4 }
  | 'case' Term 'of' Term '|' Term { Lambda.Abs.Case $2 $4 $6 }
  | 'abort' Type Term { Lambda.Abs.Abort $2 $3 }

Type :: { Lambda.Abs.Type }
Type
  : 'A' { Lambda.Abs.A }
  | 'B' { Lambda.Abs.B }
  | 'C' { Lambda.Abs.C }
  | 'T' { Lambda.Abs.T }
  | 'E' { Lambda.Abs.E }
  | 'Bot' { Lambda.Abs.Bot }
  | '(' Type '->' Type ')' { Lambda.Abs.Func $2 $4 }
  | '(' Type '+' Type ')' { Lambda.Abs.Sum $2 $4 }
  | '(' Type '*' Type ')' { Lambda.Abs.Product $2 $4 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

