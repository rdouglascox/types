<h1 id="propositions-as-types-for-philosophers">Propositions as Types
(For Philosophers)</h1>
<h2 id="introduction">Introduction</h2>
<p>We are going to implement a type-checker for an <strong>extended
Church-style simply typed lambda calculus</strong>. By ‘simply typed’
here, we mean to be drawing a contrast with more complex typing systems
such as systems with type polymorphism and dependant types. By
‘Church-style’ we mean that we will use type annotations on lambda
variables and that every term will be have a unique type. By ‘extended’
we mean that we will have type constructors other than the functional
type constructor.</p>
<p>Basic simply typed lambda calculus only has a functional type
constructor. We will have constructors for sum types, product types, and
the bottom type. Why just these? Because we want a typed lambda calculus
that will correspond to the intuitionist fragment of propositional
logic. Just to foreshadow that correspondence, we are going to have a
type constructor <code>-&gt;</code> that corresponds to implication
<code>-&gt;</code>, a type constructor <code>+</code> that corresponds
to disjunction, and a type constructor <code>*</code> that corresponds
to conjunction. We will also be able to express negation using
<code>-&gt;</code> and <code>Bot</code>.</p>
<p>When I say what we are going to implement a type-checker, I mean that
we are going to implement a function that can not only tell us in a
‘yes/no’ manner whether a term is well-typed. It will be a function that
returns a derivation proving that the term is well-typed if it is. This
derivation will look a lot like a natural deduction proof. This is
another aspect of our correspondence. A well-typed term can be thought
of as a proof of a proposition corresponding to the type. A derivation
showing that <code>\x:A.x</code> is well-typed, for instance, will be a
proof of the tautology <code>(A-&gt;A)</code>.</p>
<p>These are two parts of what is known as the Curry-Howard
correspondence. We have a correspondence here between types and
propositions and between terms and proofs. The third part has to do with
proof simplification, but set that aside for now. In a sense, in writing
a type-checker we are doing something similar to what we would do if
were writing a function for checking a natural deduction proof. A proof
checker would check whether each part of a proof corresponded to a
correct application of a rule for constructing a proof. In a natural
deduction proof the tree structure is explicit and we often annotate the
tree with rules justifying each step. When we have a term in a simply
typed lambda calculus we don’t have an explicit tree structure or rule
annotations. The terms nonetheless carry such information. The cool
thing about exploiting the correspondence to write proofs is that at the
end of the day we can run or execute our proofs.</p>
<p>In the following, we will mainly be concerned with an abstract
syntactic representation of the terms of our extended Church-style
simply typed lambda calculus. We nonetheless have a concrete syntax in
mind, and, a little later, we will take up the issue of how to parse our
concrete syntax and how to print to out concrete syntax. Let me briefly
explain the concrete syntax, then the abstract syntax, and then relate
these in a table.</p>
<h2 id="types">Types</h2>
<p>First, let me describe the syntax for our types. These annotations
are used to annotate variables. (They have another use we will come to
below). We have the following ‘base types’ <code>E</code>,
<code>T</code>. My use of <code>E</code> and <code>T</code> for base
types is a nod to philosophers’ use of <code>e</code> for entities and
<code>t</code> for things with truth values. We also have
<code>Bot</code> as the bottom or void type. It is a type that has no
elements, that cannot be instantiated. We will print this using the
unicode character <code>⊥</code> but will typically write it as
<code>Bot</code> at the keyboard. The first clause of a recursive
definition of our types might go like this then:</p>
<ul>
<li><code>E</code> and <code>T</code> and <code>⊥</code> are types.</li>
</ul>
<p>We have the following ‘type constructors’ that will allow us to
recursively generate our remaining types. These constructors are
<code>-&gt;</code>, <code>+</code>, and <code>*</code> for constructing
function types, sum types, and product types, respectively. Where we
can, we print these as <code>→</code>, <code>+</code>, and
<code>×</code> respectively. The second, third, and fourth, clauses of
our recursive definition of our types might go like this:</p>
<ul>
<li>if <code>φ</code> and <code>ψ</code> are types, then
<code>(φ→ψ)</code> is a type.</li>
<li>if <code>φ</code> and <code>ψ</code> are types, then
<code>(φ+ψ)</code> is a type.</li>
<li>if <code>φ</code> and <code>ψ</code> are types, then
<code>(φ×ψ)</code> is a type.</li>
<li>nothing else is a type.</li>
</ul>
<p>In Haskell, we define our types as follows:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">BaseType</span> <span class="ot">=</span> <span class="dt">E</span> <span class="op">|</span> <span class="dt">T</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Type</span> <span class="ot">=</span> <span class="dt">Base</span> <span class="dt">BaseType</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Bot</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Func</span> <span class="dt">Type</span> <span class="dt">Type</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Sum</span>  <span class="dt">Type</span> <span class="dt">Type</span> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Prod</span> <span class="dt">Type</span> <span class="dt">Type</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>          <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<p>We treat base types and derived types differently so that we can add
to our base types later if we like. Our typechecking function doesn’t
need to know what the base types are. It is agnostic about base
types.</p>
<h2 id="terms">Terms</h2>
<p>Now for the terms of our extended Church-style simply typed lambda
calculus. First of all, we have <strong>variables</strong>. We write
these as <code>x</code>, <code>y</code>, <code>z</code>. Variables are
our most basic terms. Next week have <strong>abstractions</strong>. We
write an abstraction like this <code>\x:(Type).Term</code>. That is, we
first write our ‘lambda’ symbol as a backslash <code>\</code> followed
by a variable, followed by a colon <code>:</code> to introduce a type
annotation, followed by a dot <code>.</code>, followed by a term.
Concretely we might write <code>\x:E.x</code>. Where we can we use the
unicode lambda character <code>λ</code> and write <code>λx:E.x</code>.
Next we have <strong>applications</strong> which we write like this
<code>(Term1 Term2)</code> or more concretely,
<code>(λx:(E→T).x y)</code>.</p>
<p>Now we get to the terms which make up our ‘extended’ calculus. We
have <strong>pairs</strong> of the product type which we write like this
<code>{Term1,Term2}</code>. We also have the two destructors related to
product types <code>fst Term</code> and <code>snd Term</code>. We have
two constructors for sum types <code>inl Term as Type</code> and
<code>inr Term as Type</code>. And we have a single destructor for the
sum type: <code>case Term of Term | Term</code>. This may need some
explaining. For reasons we will go into below, we need to annotate our
constructors for sum types with the constructed type. These constructors
are a bit like the role for disjunction introduction. If you already
have a term of type E, then you can introduce a term of sum type. But
you need to say what that type is. So we write, for instance,
<code>inl x as (E+T)</code> when we want to introduce a term of type
<code>(E+T)</code> given a term <code>x</code> of type <code>E</code>.
We will see how the sum type destructor works later. But basically, it
is going to take a term of sum type and two terms of function type
appropriately related to the sum type, and get a term of the type of the
return type of those functions. Finally, we have one more term that we
write <code>abort Type Term</code>, or, for instance
<code>abort A x</code>. If we have a term <code>x</code> of the bottom
type we can derive a term of type <code>A</code>, namely
<code>abort A x</code>.</p>
<p>Here is a recursive specification of our terms:</p>
<ul>
<li><code>x</code>, <code>y</code>, <code>z</code>, <code>x1</code>,
<code>x2</code>, … are terms.</li>
<li>if <code>v</code> is a variable and <code>t</code> is a term, and
<code>φ</code> is a type, then <code>λv:φ.t</code> is a term.</li>
<li>if <code>t1</code> and <code>t2</code> are terms, then
<code>(t1 t2)</code> is a term.</li>
<li>if <code>t1</code> and <code>t2</code> are terms, then
<code>{t1,t2}</code> is a term.</li>
<li>if <code>t</code> is a term, then <code>fst t</code> and
<code>snd t</code> are terms.</li>
<li>if <code>t</code> is a term, and <code>φ</code> is a type, then
<code>inl t as φ</code> and <code>inr t as φ</code> are terms.</li>
<li>if <code>t1</code>, <code>t2</code>, <code>t3</code>, are terms,
then <code>case t1 of t2 | t2</code> is a term.</li>
<li>if <code>t</code> is a term and <code>φ</code> is a type, then
<code>abort φ t</code> is a term.</li>
<li>nothing else is a term.</li>
</ul>
<p>In Haskell, we define our terms as follows.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">VarSym</span> <span class="ot">=</span> <span class="dt">VarSym</span> <span class="dt">Char</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span> <span class="ot">=</span> </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Var</span> <span class="dt">VarSym</span> </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Abs</span> <span class="dt">VarSym</span> <span class="dt">Type</span> <span class="dt">Term</span> </span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">App</span> <span class="dt">Term</span> <span class="dt">Term</span> </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Pair</span> <span class="dt">Term</span> <span class="dt">Term</span> </span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Fst</span> <span class="dt">Term</span> </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Snd</span> <span class="dt">Term</span> </span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Inl</span> <span class="dt">Term</span> <span class="dt">Type</span> </span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Inr</span> <span class="dt">Term</span> <span class="dt">Type</span> </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Case</span> <span class="dt">Term</span> <span class="dt">Term</span> <span class="dt">Term</span> </span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Abort</span> <span class="dt">Type</span> <span class="dt">Term</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>          <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<p>This is pretty self-explanatory. A variable symbol will just be a
character like <code>x</code> optionally followed by an integer like
<code>1</code>, e.g. <code>x1</code>. For the most part, our
type-checker won’t care what variable symbols are. All that matters is
that they are something that can be compared for equality. Hence the
clause <code>deriving (Show, Eq)</code> which ensures both that variable
symbols can be compared for equality and that they can be printed. It
may be worth remarking at this stage that it will be assumed that fresh
variables will be used wherever possible in our terms so that we don’t
have worry about variable name clashes.</p>
<h2 id="typing-rules">Typing Rules</h2>
<p>Given this syntax, we can write terms that are not
<strong>well-typed</strong>. A well-typed term is a term whose type can
be derived according to our typing rules. Now, we do not say that a term
is well typed or not in absolute terms. We say that it is well-typed or
not given a context. We are concerned with <strong>judgements</strong>
of the form <code>Γ ⊢ t</code>, where this says that term <code>t</code>
is well-typed in context <code>Γ</code>.</p>
<h3 id="variables">Variables</h3>
<pre><code>Γ, x:φ ⊢ x:φ</code></pre>
<h3 id="abstractions">Abstractions</h3>
<pre><code>Γ, x:φ ⊢ x:φ
-----------------------
Γ ⊢ λx:φ M : (φ → ψ)</code></pre>
<h3 id="applications">Applications</h3>
<pre><code>Γ ⊢ M : (φ → ψ)  Γ ⊢ N :φ
--------------------------
Γ ⊢ (M N) : ψ</code></pre>
<h3 id="products">Products</h3>
<pre><code>Γ ⊢ M : ψ  Γ ⊢ N :φ
--------------------------
Γ ⊢ {M,N} : (ψ × φ)

Γ ⊢ M : (ψ × φ)
--------------------------
Γ ⊢ fst M : ψ

Γ ⊢ M : (ψ × φ)
--------------------------
Γ ⊢ fst M : φ</code></pre>
<h3 id="sums">Sums</h3>
<pre><code>Γ ⊢ M : φ
-------------------------------
Γ ⊢ inl M as (ψ + φ) : (ψ + φ)


Γ ⊢ M : φ
-------------------------------
Γ ⊢ inr M as (ψ + φ) : (ψ + φ)


Γ ⊢ L : (ψ + φ)   Γ ⊢ M : (ψ → ρ)  Γ ⊢ M : (φ → ρ)
----------------------------------------------------
Γ ⊢ case L of M | N : p</code></pre>
<h3 id="bottom">Bottom</h3>
<pre><code>Γ ⊢ M : ⊥
--------------------
Γ ⊢ abort φ M : φ </code></pre>
<h2 id="type-checking">Type Checking</h2>
<p>Now we want to write a type-checking algorithim to check if some
arbitrary term is well-typed. Let’s think through the algorithim
informally. Suppose we are given some term M. We know that it can either
be an abstraction, an application, a variable, and so on.</p>
<p>In Haskell, that means we will be writing something like this:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">typecheck ::</span> <span class="dt">Judgement</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Type</span> </span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>typecheck ctx intrm <span class="ot">=</span> <span class="kw">case</span> term <span class="kw">of</span> </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Var</span> vsymb <span class="ot">-&gt;</span>  </span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Abs</span> vsymb typ trm <span class="ot">-&gt;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">App</span> trm1 trm2 <span class="ot">-&gt;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Pair</span> trm1 trm2 <span class="ot">-&gt;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Fst</span> trm <span class="ot">-&gt;</span> </span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Snd</span> trm <span class="ot">-&gt;</span>  </span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Inl</span> trm typ <span class="ot">-&gt;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Inr</span> trm typ <span class="ot">-&gt;</span> </span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Case</span> trm1 trm2 trm3 <span class="ot">-&gt;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Abort</span> typ trm <span class="ot">-&gt;</span></span></code></pre></div>
<p>What do we do if it is a variable? Well, we just check that the
variable is assigned a type in the context. If it is, that’s great, it
is well-typed in the context. Rather than just return a boolean ‘yes’ or
‘no’. Let’s assume that our function returns the type of the variable if
it succeeds. This will be helpful if we are trying to work out the type
of a term the variable occurrs free in.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">typecheck ::</span> <span class="dt">Judgement</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Type</span> </span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>typecheck ctx intrm <span class="ot">=</span> <span class="kw">case</span> term <span class="kw">of</span> </span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Var</span> vsymb <span class="ot">-&gt;</span> Map.lookup vsymb ctx </span></code></pre></div>
<p>What do we do if the term is an abstraction? Well, if it is an
abstraction, we know it is a functional type. And we know that the
‘input’ type for the function is the type given in the annotation of the
variable. The return type will be φ on the assumption that the body term
M has type φ in the context Γ extended by the variable assignment
corresponding to the annotation of the lambda variable. The abstraction
is well-typed assuming that the body term M is well-typed.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">typecheck ::</span> <span class="dt">Judgement</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Type</span> </span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>typecheck ctx intrm <span class="ot">=</span> <span class="kw">case</span> term <span class="kw">of</span> </span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Abs</span> vsymb typ trm <span class="ot">-&gt;</span> <span class="kw">let</span> newctx <span class="ot">=</span> Map.insert vsymb typ ctx </span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>                            bdytrmtyp <span class="ot">=</span> typecheck newctx trm <span class="kw">in</span> </span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">Func</span> <span class="op">&lt;$&gt;</span> <span class="dt">Just</span> typ <span class="op">&lt;*&gt;</span> bdytrmtyp </span></code></pre></div>
<p>What do we do if the term is an application? Well, if it is an
application, it is well-typed if both M and N are well typed and M is a
functional type and N is the type of the ‘input’ type of M. (M N) will
have the return type of M.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">typecheck ::</span> <span class="dt">Judgement</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Type</span> </span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>typecheck ctx intrm <span class="ot">=</span> <span class="kw">case</span> term <span class="kw">of</span> </span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">App</span> trm1 trm2 <span class="ot">-&gt;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> trm1typ <span class="ot">=</span> typecheck ctx trm1 </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>          trm2typ <span class="ot">=</span> typecheck ctx trm2 <span class="kw">in</span> </span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> trm1typ <span class="kw">of</span> </span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>         <span class="dt">Just</span> (<span class="dt">Func</span> ityp otyp) <span class="ot">-&gt;</span> <span class="kw">if</span> <span class="dt">Just</span> ityp <span class="op">==</span> trm2typ <span class="kw">then</span> <span class="dt">Just</span> otyp <span class="kw">else</span> <span class="dt">Nothing</span> </span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>         _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>What do we do if the term is a pair? Well, if it is a pair it a
product type. It is well-typed if both M and N are well typed. And its
type is the type (ψ × φ) where ψ is the type of M and φ the type of
N.</p>
<h2 id="printing">Printing</h2>
<h2 id="parsing">Parsing</h2>
